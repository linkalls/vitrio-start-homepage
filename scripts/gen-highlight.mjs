import { createHighlighter } from 'shiki'
import { writeFileSync } from 'node:fs'
import { join } from 'node:path'

const SNIPS = [
  {
    key: 'routes_ts',
    lang: 'ts',
    code: `defineRoute({
  path: '/reference',
  loader: (ctx) => ({ /* ... */ }),
  action: (ctx, formData) => ({ /* ... */ }),
  component: ({ data, csrfToken }) => <Page />,
})`,
  },
  {
    key: 'action_ts',
    lang: 'ts',
    code: `import { redirect } from './server/response'

export const action = async (ctx, formData) => {
  const email = formData.get('email')
  
  // 1. Validation
  if (!email || typeof email !== 'string') {
    // Return redirect with flash (handled by framework)
    // Note: framework.tsx handles the actual cookie setting based on return value
    // or you can set it manually if you modify framework.
    // In default starter:
    return { ok: false, error: 'Email is required' }
  }

  // 2. Mutation (e.g. D1, KV)
  await ctx.env.DB.prepare('INSERT INTO users...').run()

  // 3. Success (PRG)
  return redirect('/thanks', { status: 303 })
}`,
  },
  {
    key: 'framework_post_ts',
    lang: 'ts',
    code: `// src/server/framework.tsx (Simplified)
if (method === 'POST') {
  const r = await runMatchedAction(c, routes, path, url)

  if (r.kind === 'redirect') {
    return c.redirect(r.to, r.status)
  }
  
  // Set flash cookie based on result
  setFlash(c, { ok: r.kind === 'ok', at: Date.now() })
  return c.redirect(path, 303)
}`,
  },
  {
    key: 'form_html',
    lang: 'html',
    code: `<form method="post">\n  <input type="hidden" name="_csrf" value={csrfToken} />\n  ...\n</form>`,
  },
  {
    key: 'headers_text',
    lang: 'text',
    code: `X-Content-Type-Options: nosniff\nReferrer-Policy: strict-origin-when-cross-origin\nContent-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'`,
  },
  {
    key: 'wrangler_toml',
    lang: 'toml',
    code: `[assets]\ndirectory = "dist/client"\nbinding = "ASSETS"\nrun_worker_first = false`,
  },
  {
    key: 'commands_bash',
    lang: 'bash',
    code: `bun run dev\nbun run build\nbunx wrangler deploy`,
  },
  {
    key: 'hero_route_ts',
    lang: 'ts',
    code: `defineRoute({
  path: '/posts/:slug',
  // 1. Loader: Fetch data on GET (runs before SSR)
  loader: async ({ params, env }) => {
    const post = await env.DB.prepare('SELECT * FROM posts WHERE slug = ?')
      .bind(params.slug).first()
    if (!post) return { notFound: true }
    return { post }
  },
  // 2. Action: Handle POST (PRG pattern)
  action: async ({ params, request, env }) => {
    const fd = await request.formData()
    await env.DB.prepare('UPDATE posts SET likes = likes + 1 WHERE slug = ?')
      .bind(params.slug).run()
    return redirect(\`/posts/\${params.slug}\`, 303)
  },
  // 3. Component: Render HTML (SSR)
  component: ({ data, csrfToken }) => (
    <article>
      <h1>{data.post.title}</h1>
      <form method="post">
        <input type="hidden" name="_csrf" value={csrfToken} />
        <button>Like ({data.post.likes})</button>
      </form>
    </article>
  ),
})`,
  },
  {
    key: 'routing_param_ts',
    lang: 'ts',
    code: `defineRoute({
  path: '/users/:id', // matches /users/123
  loader: ({ params }) => {
    // params.id is "123"
    return { userId: params.id }
  },
  component: ({ data }) => <div>User {data.userId}</div>
})`,
  },
  {
    key: 'loader_example_ts',
    lang: 'ts',
    code: `loader: async ({ params, env }) => {
  // Parallel fetch
  const [user, posts] = await Promise.all([
    fetchUser(params.id),
    fetchPosts(params.id),
  ])
  
  // Return plain object (serialization-safe)
  // This is passed to component as 'data' prop
  return { user, posts }
}`,
  },
  {
    key: 'worker_env_ts',
    lang: 'ts',
    code: `// src/server/workers.ts
export default {
  fetch(request: Request, env: Env, ctx: any) {
    // Inject env into global scope for deep access without prop drilling
    // (A pragmatic tradeoff for SSR frameworks on Workers)
    ;(globalThis as any).__VITRIO_ENV = env
    return app.fetch(request, env, ctx)
  },
}`,
  },
]

const h = await createHighlighter({
  themes: ['github-dark'],
  langs: ['ts', 'tsx', 'html', 'toml', 'bash', 'text'],
})

const out = {}
for (const s of SNIPS) {
  out[s.key] = h.codeToHtml(s.code, { lang: s.lang, theme: 'github-dark' })
}

const file = `// AUTO-GENERATED by scripts/gen-highlight.mjs\n// Do not edit manually.\n\nexport const HIGHLIGHT = ${JSON.stringify(out, null, 2)} as const\n`
writeFileSync(join(process.cwd(), 'src/server/highlight.ts'), file, 'utf8')
console.log('[gen-highlight] wrote src/server/highlight.ts')
